   ### 学习go的第一天

> go中的包模型采用了显示依赖关系的机制来达到快速编译的目的。
如果对一个包进行了更改或者重新编译，所有引用这个包的客户端程序都必须重新编译。

go每一段代码都只会被编译一次

当标识符以大写字母开头，那么使用这种形式的标志符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包）

> go的基本类型有四种:int float bool string<br>
> 结构化类型（复合）:struct arry slice map channel<br>
> 之描述类型的行为的：interface


  结构化的类型的没有真正的值，它使用nil作为默认值。go语言中不存在类型的继承。
函数也可以是一个确定的类型，就是以函数作为返回类型，这种类型的声明要写在函数名的可选的参数列表之后

```go
func FunctionName(a typea) typeFunc
```
因式分解关键字的写法，一般用于声明全部变量
Go 是在编译的时候就已经完成了变量的推断过程
```go
var a = 15
var b = false
var str = "Go says hello to the world!"
c:=123
```
* 一个引用类型的变量r1存储的值是r1的值所在的内存地址（是一串数字），或内存地址中第一个字所在的位置。而且这个内存地址被称为指针，且这个指针实际上也被存在另外的某一个字中。
* 同一个引用类型的指针指向的多个字可以是 在连续的内存地址中（内存的布局是连续的）这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址
* 被引用的类型会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间


go 中可以并行（同时）赋值
如果你想交换两个变量的值，则可以简单地使用
```go
a,b=b,a
```
* _ 实际上只是一个只写变量，你不能得到他的值。这样做是因为Go语言中，你必须使用所有被声明的变量，但有时候你不需要使用从一个函数中得到的所有返回值，如：

```go
va1,err=func1(var1)
```

* init()函数，它不能够被人为的调用，而是在每个包完成初始化周自动执行，并且优先级比main函数高。<b>初始化总是以单线程执行，并且按照包的依赖关系顺序执行的。


> <b> init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 backend()：
```go
func init() {
   // setup preparations
   go backend()
}
```